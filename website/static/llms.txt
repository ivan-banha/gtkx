# GTKX

> Build native GTK4 desktop applications with React and TypeScript

GTKX is a framework for building native GTK4 desktop applications using React and TypeScript. It bridges React's component model with GTK4's native widget system via a custom React Reconciler and Rust-based FFI bindings.

## Key Features

- **React Components**: Use React hooks, state, props, and component patterns
- **Hot Module Replacement**: Edit your code and see changes instantly, powered by Vite
- **Native Performance**: Direct FFI bindings to GTK4 via Rust and libffi (no Electron overhead)
- **CLI & Scaffolding**: Get started in seconds with `npx @gtkx/cli@latest create`
- **CSS-in-JS Styling**: Emotion-style `css` template literals for GTK widgets
- **Testing Library**: Familiar `screen`, `userEvent`, and query APIs for testing components

## Documentation

- Homepage: https://eugeniodepalo.github.io/gtkx/
- Introduction: https://eugeniodepalo.github.io/gtkx/docs/introduction
- Getting Started: https://eugeniodepalo.github.io/gtkx/docs/getting-started
- API Reference: https://eugeniodepalo.github.io/gtkx/docs/api/react
- GitHub: https://github.com/eugeniodepalo/gtkx

## Architecture

```
React JSX -> @gtkx/react (Reconciler) -> @gtkx/ffi (TS wrappers) -> @gtkx/native (Rust) -> libffi -> GTK4
```

1. You write React components using JSX
2. The GTKX reconciler converts React elements into GTK widget nodes
3. TypeScript FFI bindings marshal calls to native GTK4 via Rust
4. GTK4 renders native widgets on your Linux desktop

## Packages

| Package | Description |
|---------|-------------|
| @gtkx/cli | CLI for creating and developing GTKX apps with HMR |
| @gtkx/react | React reconciler and JSX components |
| @gtkx/ffi | TypeScript FFI bindings for GTK4, GLib, GIO, Gdk |
| @gtkx/native | Rust native module providing the FFI bridge |
| @gtkx/css | CSS-in-JS styling for GTK widgets (Emotion-style API) |
| @gtkx/testing | Testing utilities with a Testing Library-style API |
| @gtkx/gir | GObject Introspection parser for code generation |

## Examples

| Example | Description |
|---------|-------------|
| gtk4-demo | Comprehensive GTK4 widget showcase |
| todo | Todo app demonstrating @gtkx/testing with realistic component tests |

## Quick Start

### Prerequisites

- Node.js 20+
- GTK4 development libraries (`sudo dnf install gtk4-devel` on Fedora, `sudo apt install libgtk-4-dev` on Ubuntu, `sudo pacman -S gtk4` on Arch)
- Linux (GTK4 is Linux-native)

### Create a New App

```bash
npx @gtkx/cli@latest create
```

This launches an interactive wizard that sets up your project with TypeScript, your preferred package manager, and optional testing support.

You can also pass options directly:

```bash
npx @gtkx/cli@latest create my-app --app-id com.example.myapp --pm pnpm --testing vitest
```

Then start developing with HMR:

```bash
cd my-app
npm run dev
```

Edit your code and see changes instantly without restarting the app!

### Manual Setup

Alternatively, install packages directly:

```bash
npm install @gtkx/cli @gtkx/react @gtkx/ffi react
npm install -D @types/react typescript
npm install @gtkx/css                        # For styling (optional)
npm install -D @gtkx/testing                 # For testing (optional)
```

Create your first app:

```tsx
// src/app.tsx
import { useState } from "react";
import * as Gtk from "@gtkx/ffi/gtk";
import { ApplicationWindow, Box, Button, Label, quit } from "@gtkx/react";

export default function App() {
  const [count, setCount] = useState(0);

  return (
    <ApplicationWindow
      title="My App"
      defaultWidth={400}
      defaultHeight={300}
      onCloseRequest={quit}
    >
      <Box orientation={Gtk.Orientation.VERTICAL} spacing={12} marginStart={20} marginEnd={20} marginTop={20}>
        <Label.Root label={`Count: ${count}`} />
        <Button label="Increment" onClicked={() => setCount((c) => c + 1)} />
      </Box>
    </ApplicationWindow>
  );
}

export const appId = "org.example.MyApp";
```

```tsx
// src/index.tsx
import { render } from "@gtkx/react";
import App, { appId } from "./app.js";

render(<App />, appId);
```

Run with HMR:

```bash
npx gtkx dev src/app.tsx
```

## Core Concepts

### Rendering

The `render(element, appId)` function is the entry point:
- Initializes the GTK main loop
- Creates a GTK Application with the given ID (reverse domain notation)
- Mounts your React element tree
- Starts the event loop

### quit()

Cleanly shuts down the application by:
1. Unmounting the React tree
2. Stopping the GTK main loop

Always use `quit()` in `onCloseRequest` to ensure proper cleanup.

### ApplicationWindow

The main window component with key props:
- `title`: Window title
- `defaultWidth` / `defaultHeight`: Initial window size
- `onCloseRequest`: Called when the window close button is clicked (use `quit()` for cleanup)

### Layout Components

- **Box**: Primary layout container. Use `orientation` (HORIZONTAL/VERTICAL) and `spacing` for gaps
- **Grid**: Two-dimensional layout with explicit row/column positioning and spanning
- **Stack**: Shows one child at a time, useful for multi-page interfaces
- **CenterBox**: Arranges three children with the middle one centered
- **Paned**: Two resizable panes with a draggable separator

### Event Handling

GTK signals are exposed as React props with the `on` prefix:
- `onClicked`: Button clicks
- `onCloseRequest`: Window close
- `onChanged`: Text input changes
- `onActivate`: Widget activation
- `onToggled`: Toggle state changes

## Widget Slots

GTK widgets often have named child properties like `titleWidget`, `child`, or `label`. GTKX exposes these as slots following the pattern `<Widget.SlotName>`:

```tsx
// Expander with child content
<Expander.Root label="Click to expand">
  <Expander.Child>
    <Label.Root label="Hidden content" />
  </Expander.Child>
</Expander.Root>

// HeaderBar with custom title widget
<HeaderBar.Root>
  <HeaderBar.TitleWidget>
    <Box orientation={Orientation.HORIZONTAL} spacing={8}>
      <Label.Root label="My App" cssClasses={["heading"]} />
    </Box>
  </HeaderBar.TitleWidget>
</HeaderBar.Root>

// Window with custom titlebar (use Window for slots)
<Window.Root onCloseRequest={quit}>
  <Window.Titlebar>
    <HeaderBar.Root />
  </Window.Titlebar>
  <Window.Child>
    {/* Main content */}
  </Window.Child>
</Window.Root>

// Frame with child
<Frame.Root label="Settings">
  <Frame.Child>
    <Label.Root label="Frame content" />
  </Frame.Child>
</Frame.Root>
```

Every widget with slots has:
- `Widget.Root`: The actual GTK widget (creates the widget instance)
- `Widget.SlotName`: Named slots for specific child properties (virtual, no widget created)

Slots work with React's conditional rendering and automatically swap content when conditions change.

## Portals

Portals render React children into a different part of the GTK widget tree. Essential for dialogs, popovers, and overlay content.

```tsx
import { createPortal, AboutDialog, ApplicationWindow, Button, quit } from "@gtkx/react";
import { useState } from "react";

const App = () => {
  const [showDialog, setShowDialog] = useState(false);

  return (
    <ApplicationWindow title="My App" onCloseRequest={quit}>
      <Button label="Show Dialog" onClicked={() => setShowDialog(true)} />

      {showDialog && createPortal(
        <AboutDialog
          programName="My App"
          version="1.0.0"
          onCloseRequest={() => {
            setShowDialog(false);
            return false;
          }}
        />
      )}
    </ApplicationWindow>
  );
};
```

API: `createPortal(children, container?, key?)`
- Without container: Renders at application root level
- With container: Renders into the specified widget
- React events bubble through the React tree, not the GTK tree
- React context passes through portals normally

### Portal vs Slot

- **Slots** (`Widget.SlotName`): Place content in a widget's named property (e.g., `setChild()`)
- **Portals** (`createPortal`): Render content in a completely different widget container

## Grid Layout

Two-dimensional layout with explicit row/column positioning:

```tsx
import { Grid, Label, Entry, Button } from "@gtkx/react";
import { Align } from "@gtkx/ffi/gtk";

<Grid.Root columnSpacing={12} rowSpacing={8}>
  <Grid.Child row={0} column={0}>
    <Label.Root label="Username:" halign={Align.END} />
  </Grid.Child>
  <Grid.Child row={0} column={1}>
    <Entry hexpand />
  </Grid.Child>
  <Grid.Child row={1} column={0} columnSpan={2}>
    <Button label="Login" cssClasses={["suggested-action"]} />
  </Grid.Child>
</Grid.Root>
```

Grid.Root props: `columnSpacing`, `rowSpacing`, `columnHomogeneous`, `rowHomogeneous`
Grid.Child props: `row`, `column`, `rowSpan`, `columnSpan`

## Lists and Data Binding

GTKX provides virtualized list components for large datasets:

### ListView

```tsx
import * as Gtk from "@gtkx/ffi/gtk";
import { ListView, Label, ScrolledWindow } from "@gtkx/react";

interface User {
  id: string;
  name: string;
}

const users: User[] = [/* ... */];

<ScrolledWindow vexpand>
  <ListView.Root
    renderItem={(user: User | null) => (
      <Label.Root
        label={user?.name ?? ""}
        halign={Gtk.Align.START}
      />
    )}
  >
    {users.map(user => (
      <ListView.Item key={user.id} item={user} />
    ))}
  </ListView.Root>
</ScrolledWindow>
```

The `renderItem` function receives:
- `item`: The data item to render, or `null` during setup (for loading/placeholder state)

### GridView

Grid layout with automatic wrapping:

```tsx
<GridView.Root
  renderItem={(photo: Photo | null) => (
    <Label.Root label={photo?.title ?? ""} />
  )}
>
  {photos.map(photo => (
    <GridView.Item key={photo.id} item={photo} />
  ))}
</GridView.Root>
```

### ColumnView (Tables)

Tabular data with multiple columns and optional sorting:

```tsx
const sortFn = (a: Product, b: Product, columnId: string) => {
  if (columnId === "name") return a.name.localeCompare(b.name);
  if (columnId === "price") return a.price - b.price;
  return 0;
};

<ColumnView.Root
  sortColumn={sortColumn}
  sortOrder={sortOrder}
  onSortChange={(column, order) => { setSortColumn(column); setSortOrder(order); }}
  sortFn={sortFn}
>
  <ColumnView.Column
    id="name"
    title="Name"
    expand
    renderCell={(product: Product | null, ref: RefCallback<Gtk.Widget>) => (
      <Label.Root ref={ref} label={product?.name ?? ""} />
    )}
  />
  <ColumnView.Column
    id="price"
    title="Price"
    fixedWidth={100}
    renderCell={(product: Product | null, ref: RefCallback<Gtk.Widget>) => (
      <Label.Root ref={ref} label={product ? `$${product.price}` : ""} />
    )}
  />
  {products.map(product => (
    <ColumnView.Item key={product.id} item={product} />
  ))}
</ColumnView.Root>
```

ColumnView.Root sorting props:
- `sortColumn`: The column id currently sorted by (controlled)
- `sortOrder`: `Gtk.SortType.ASCENDING` or `Gtk.SortType.DESCENDING`
- `onSortChange`: Callback when user clicks column headers to change sort
- `sortFn`: Comparison function `(a, b, columnId) => number`

ColumnView.Column requires `id` prop for sorting to work.

### DropDown

Selection dropdown:

```tsx
<DropDown.Root
  itemLabel={(country: Country) => country.name}
  onSelectionChanged={(country: Country) => setSelected(country)}
>
  {countries.map(country => (
    <DropDown.Item key={country.id} item={country} />
  ))}
</DropDown.Root>
```

### When to Use Lists vs Array Mapping

Use `ListView`/`GridView` when: 100+ items, uniform sizes, need virtualization
Use standard array mapping when: fewer than 50 items, varying sizes, complex conditional rendering

## Dialogs

### Declarative Dialogs with Portals

```tsx
{showAbout && createPortal(
  <AboutDialog
    programName="My App"
    version="1.0.0"
    licenseType={License.MIT_X11}
    onCloseRequest={() => {
      setShowAbout(false);
      return false;
    }}
  />
)}
```

### Promise-Based AlertDialog

```tsx
import { getCurrentApp } from "@gtkx/ffi";
import { AlertDialog } from "@gtkx/ffi/gtk";

const showConfirmDialog = async () => {
  const app = getCurrentApp();
  const dialog = new AlertDialog();
  dialog.setMessage("Confirm Action");
  dialog.setDetail("Are you sure?");
  dialog.setButtons(["Cancel", "Delete"]);
  dialog.setCancelButton(0);
  dialog.setDefaultButton(1);

  try {
    const response = await dialog.choose(app.getActiveWindow() ?? undefined);
    // response is button index (0 = Cancel, 1 = Delete)
  } catch {
    // Dialog was dismissed
  }
};
```

### FileDialog

```tsx
import { getCurrentApp } from "@gtkx/ffi";
import { FileDialog, FileFilter } from "@gtkx/ffi/gtk";

const openFile = async () => {
  const app = getCurrentApp();
  const dialog = new FileDialog();
  dialog.setTitle("Open File");

  try {
    const file = await dialog.open(app.getActiveWindow() ?? undefined);
    console.log(file.getPath());
  } catch {
    // User cancelled
  }
};

const saveFile = async () => {
  const app = getCurrentApp();
  const dialog = new FileDialog();
  dialog.setTitle("Save File");
  dialog.setInitialName("document.txt");

  const file = await dialog.save(app.getActiveWindow() ?? undefined);
};
```

### ColorDialog and FontDialog

```tsx
import { ColorDialog, FontDialog } from "@gtkx/ffi/gtk";

const color = await new ColorDialog().chooseRgba(window);
const font = await new FontDialog().chooseFont(window);
```

## Styling with @gtkx/css

### Basic Usage

```tsx
import { css } from "@gtkx/css";
import { Button } from "@gtkx/react";

const primaryButton = css`
  padding: 16px 32px;
  border-radius: 24px;
  background: #3584e4;
  color: white;
  font-weight: bold;
`;

<Button label="Click me" cssClasses={[primaryButton]} />
```

### Combining Styles

```tsx
import { css, cx } from "@gtkx/css";

const baseButton = css`
  padding: 12px 24px;
  border-radius: 8px;
`;

const successButton = css`
  background: #33d17a;
  color: white;
`;

<Button cssClasses={[cx(baseButton, successButton)]} label="Success" />
```

### Global Styles

```tsx
import { injectGlobal } from "@gtkx/css";

injectGlobal`
  window {
    background: #fafafa;
  }

  button:hover {
    filter: brightness(1.1);
  }
`;
```

### GTK CSS Properties

Colors: `background`, `color`, `opacity`
Spacing: `padding`, `margin`, `min-width`, `min-height`
Borders: `border`, `border-radius`
Typography: `font-size`, `font-weight`, `font-family`
Effects: `box-shadow`, `transition`

### Built-in CSS Classes

Button variants: `suggested-action`, `destructive-action`, `flat`, `circular`
Typography: `title-1`, `title-2`, `heading`, `caption`, `dim-label`
Containers: `card`, `boxed-list`

### Theme Color Variables

```css
@accent_bg_color, @accent_fg_color  /* Accent colors */
@window_bg_color, @window_fg_color  /* Window colors */
@card_bg_color, @card_shade_color   /* Card colors */
@success_color, @warning_color, @error_color  /* Status colors */
```

## Testing with @gtkx/testing

### Setup

Tests require `xvfb-run` because GTK needs a display:
```bash
GDK_BACKEND=x11 xvfb-run -a pnpm vitest run
```

### Basic Test

```tsx
import { cleanup, render, screen, userEvent } from "@gtkx/testing";
import { AccessibleRole } from "@gtkx/ffi/gtk";
import { afterEach, test, expect } from "vitest";

afterEach(async () => {
  await cleanup();
});

test("increments count when clicking button", async () => {
  await render(<Counter />);

  const button = await screen.findByRole(AccessibleRole.BUTTON, {
    name: "Increment",
  });
  await userEvent.click(button);

  await screen.findByText("Count: 1");
});
```

### Query Functions

All queries are async and will wait for elements (default timeout: 1000ms):

| Query | Returns | Throws if not found? |
|-------|---------|---------------------|
| `findBy*` | Single element | Yes |
| `findAllBy*` | Array | Yes (if empty) |

Query methods:
- `findByText(text)` / `findAllByText(text)`: By text content (supports regex)
- `findByRole(role, options?)` / `findAllByRole`: By accessible role
- `findByLabelText(text)` / `findAllByLabelText`: By label text
- `findByTestId(id)` / `findAllByTestId`: By widget name prop

Common roles: `AccessibleRole.BUTTON`, `AccessibleRole.LABEL`, `AccessibleRole.TEXT_BOX`, `AccessibleRole.CHECKBOX`, `AccessibleRole.SWITCH`

### User Interactions

```tsx
import { userEvent } from "@gtkx/testing";

await userEvent.click(element);
await userEvent.dblClick(element);
await userEvent.tripleClick(element);
await userEvent.activate(entry);  // e.g., press Enter in input
await userEvent.type(input, "Hello");
await userEvent.clear(input);
await userEvent.tab(element);  // Tab navigation
await userEvent.tab(element, { shift: true });  // Shift+Tab
await userEvent.selectOptions(dropdown, 0);  // Select by index
await userEvent.deselectOptions(listbox, [0, 1]);  // Deselect in ListBox
```

### Low-Level Events

```tsx
import { fireEvent } from "@gtkx/testing";

// Fire any GTK signal by name
fireEvent(button, "clicked");
fireEvent(entry, "activate");
fireEvent(checkbox, "toggled");

// Pass additional arguments to signal handlers
fireEvent(widget, "custom-signal", { type: { type: "int", size: 32 }, value: 42 });
```

### Waiting for Changes

```tsx
import { waitFor, waitForElementToBeRemoved } from "@gtkx/testing";

await waitFor(async () => {
  const message = await screen.findByText("Success!");
  expect(message).toBeDefined();
}, { timeout: 2000, interval: 100 });

const loader = await screen.findByText("Loading...");
await waitForElementToBeRemoved(loader);
```

### Scoped Queries with within

```tsx
import { within } from "@gtkx/testing";

const dialog = await screen.findByRole(AccessibleRole.DIALOG);
const { findByRole, findByText } = within(dialog);

const confirmButton = await findByRole(AccessibleRole.BUTTON, { name: "Confirm" });
```

### Render Options

```tsx
// Default: wraps in ApplicationWindow
await render(<Button label="Test" />);

// Custom wrapper (replaces default)
const Wrapper = ({ children }) => (
  <ApplicationWindow>
    <ThemeProvider>{children}</ThemeProvider>
  </ApplicationWindow>
);
await render(<MyComponent />, { wrapper: Wrapper });

// Disable wrapper for multi-window tests
await render(<>
  <ApplicationWindow><Content1 /></ApplicationWindow>
  <ApplicationWindow><Content2 /></ApplicationWindow>
</>, { wrapper: false });
```

### RenderResult

```tsx
const { container, rerender, unmount, debug, findByText, ... } = await render(<App />);

await rerender(<App newProp="value" />);
debug();  // Print widget tree
await unmount();
```

## Common Widgets

### Buttons
```tsx
<Button label="Click me" onClicked={handleClick} />
<Button iconName="list-add" cssClasses={["circular"]} />
<ToggleButton.Root label="Toggle" active={isActive} onToggled={() => setActive(!isActive)} />
<CheckButton.Root label="Option" active={checked} onToggled={() => setChecked(!checked)} />
<Switch active={enabled} onStateSet={(_self, state) => { setEnabled(state); return true; }} />
```

### Labels
```tsx
<Label.Root label="Plain text" />
<Label.Root label="<b>Bold</b> markup" useMarkup />
<Label.Root label="Wrapped text" wrap />
```

### Text Input
```tsx
<Entry placeholderText="Enter text" onChanged={handleChange} />
<PasswordEntry placeholderText="Password" />
<SearchEntry placeholderText="Search..." />
<TextView />  /* Multi-line */
<SpinButton adjustment={adj} />  /* Numeric */
```

### Containers
```tsx
<Box orientation={Orientation.VERTICAL} spacing={12}>
  {/* children */}
</Box>

<ScrolledWindow vexpand>
  {/* scrollable content */}
</ScrolledWindow>

<Frame.Root label="Section">
  <Frame.Child>{/* content */}</Frame.Child>
</Frame.Root>

<Expander.Root label="Details">
  <Expander.Child>{/* content */}</Expander.Child>
</Expander.Root>

<Revealer revealChild={show} transitionType={RevealerTransitionType.SLIDE_DOWN}>
  {/* animated content */}
</Revealer>
```

### Navigation
```tsx
<Stack.Root visibleChildName={currentPage}>
  <Stack.Page name="page1" title="Page 1">{/* content */}</Stack.Page>
  <Stack.Page name="page2" title="Page 2">{/* content */}</Stack.Page>
</Stack.Root>
<StackSwitcher.Root />

<Notebook.Root>
  <Notebook.Page label="Tab 1">{/* content */}</Notebook.Page>
  <Notebook.Page label="Tab 2">{/* content */}</Notebook.Page>
</Notebook.Root>
```

### Menus

Application-wide menu bar (must be a sibling of ApplicationWindow at root level):
```tsx
export const App = () => (
  <>
    <ApplicationMenu>
      <Menu.Submenu label="File">
        <Menu.Item label="New" onActivate={handleNew} accels="<Control>n" />
        <Menu.Item label="Open" onActivate={handleOpen} accels="<Control>o" />
        <Menu.Section>
          <Menu.Item label="Quit" onActivate={quit} accels="<Control>q" />
        </Menu.Section>
      </Menu.Submenu>
      <Menu.Submenu label="Help">
        <Menu.Item label="About" onActivate={showAbout} />
      </Menu.Submenu>
    </ApplicationMenu>
    <ApplicationWindow title="My App" showMenubar onCloseRequest={quit}>
      {/* content */}
    </ApplicationWindow>
  </>
);
```

PopoverMenu for context menus and menu buttons:
```tsx
<MenuButton.Root label="Options">
  <MenuButton.Popover>
    <PopoverMenu.Root>
      <Menu.Item label="Cut" onActivate={handleCut} accels="<Control>x" />
      <Menu.Item label="Copy" onActivate={handleCopy} accels="<Control>c" />
      <Menu.Item label="Paste" onActivate={handlePaste} accels="<Control>v" />
    </PopoverMenu.Root>
  </MenuButton.Popover>
</MenuButton.Root>
```

Menu.Item props:
- `label`: Display text
- `onActivate`: Click handler
- `accels`: Keyboard accelerator (e.g., `"<Control>s"`, `"<Control><Shift>n"`)

PopoverMenuBar for inline menu bars in content area:
```tsx
<Box orientation={Orientation.VERTICAL}>
  <PopoverMenuBar>
    <Menu.Submenu label="File">
      <Menu.Item label="New" onActivate={handleNew} />
      <Menu.Item label="Quit" onActivate={quit} />
    </Menu.Submenu>
  </PopoverMenuBar>
  {/* content */}
</Box>
```

Differences: `ApplicationMenu` shows in window titlebar (requires `showMenubar`), `PopoverMenuBar` shows inline in content.

### Dialogs
```tsx
<AboutDialog programName="My App" version="1.0" />
<MessageDialog heading="Confirm" body="Are you sure?" />
```

### Media
```tsx
<Image iconName="dialog-information" />
<Picture file={gioFile} />  /* file is a Gio.File */
<Video file={gioFile} />    /* file is a Gio.File */
<Spinner spinning />
<ProgressBar fraction={0.5} />
<LevelBar value={75} maxValue={100} />
```

## API Reference

### @gtkx/cli

Commands:
- `gtkx create [name]`: Create a new GTKX project with interactive wizard
  - `--app-id`: GTK application ID (reverse domain notation)
  - `--pm`: Package manager (npm, pnpm, yarn, bun)
  - `--testing`: Testing framework (vitest, jest, node, none)
- `gtkx dev <entry>`: Start development server with Hot Module Replacement

App file requirements for `gtkx dev`:
- Must export a default function component
- Should export `appId` constant (falls back to "org.gtkx.dev")
- Can export `appFlags` for GIO ApplicationFlags (optional)

### @gtkx/react

Functions:
- `render(element, appId)`: Render React element as GTK application
- `quit()`: Quit application and cleanup
- `createPortal(children, container?, key?)`: Render into different container
- `update(element)`: Re-render with new element (used internally by HMR)

100+ widget components including: AboutDialog, ActionBar, ApplicationMenu, ApplicationWindow, Box, Button, Calendar, CheckButton, ColumnView, DropDown, Entry, Expander, Frame, Grid, GridView, HeaderBar, Image, Label, ListView, Menu (with Item, Section, Submenu), MenuButton, Notebook, Overlay, Paned, PasswordEntry, Picture, Popover, PopoverMenu, ProgressBar, Revealer, Scale, ScrolledWindow, SearchEntry, Spinner, Stack, Switch, TextView, ToggleButton, Video, Window, and more.

### @gtkx/ffi

Functions:
- `start(appId)`: Start GTK application
- `stop()`: Stop GTK application
- `getCurrentApp()`: Get current GTK Application instance
- `getObject<T>(id)`: Wrap native pointer in class instance with runtime type lookup
- `cast<T>(obj)`: Type-only cast for interface access (no runtime validation)
- `registerClass(Class)`: Register a class for runtime type lookup

Variables:
- `events`: EventEmitter for GTK lifecycle ("start", "stop")
- `createRef`: Create refs for GTK widgets
- `getObjectAddr`: Get native pointer address for GTK objects

Types:
- `NativeObject`: Base interface for all native GLib/GTK objects (`{ id: unknown }`)

Classes:
- `NativeError`: Error wrapping GLib GError

### @gtkx/css

Functions:
- `css`: Create CSS class from template literal
- `cx(...classes)`: Merge class names
- `injectGlobal`: Inject global CSS styles

### @gtkx/testing

Functions:
- `render(element, options?)`: Render for testing
- `cleanup()`: Unmount and reset (call in afterEach)
- `teardown()`: Full GTK cleanup (global teardown)
- `waitFor(callback, options?)`: Wait for condition
- `waitForElementToBeRemoved(element)`: Wait for removal
- `within(container)`: Scope queries to container

Query functions: `findByRole`, `findByText`, `findByLabelText`, `findByTestId`, `findAllByRole`, `findAllByText`, `findAllByLabelText`, `findAllByTestId`

Variables:
- `screen`: Global query methods
- `userEvent`: Simulate user interactions (click, dblClick, tripleClick, activate, type, clear, tab, selectOptions, deselectOptions)
- `fireEvent`: Fire GTK signals directly (low-level, accepts varargs)

## License

MPL-2.0
